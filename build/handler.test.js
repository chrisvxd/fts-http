"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const ava_1 = __importDefault(require("ava"));
const clone_deep_1 = __importDefault(require("clone-deep"));
const fs_extra_1 = __importDefault(require("fs-extra"));
const fts_1 = require("fts");
const fts_validator_1 = require("fts-validator");
const get_port_1 = __importDefault(require("get-port"));
const globby_1 = __importDefault(require("globby"));
const got_1 = __importDefault(require("got"));
const json_schema_faker_1 = __importDefault(require("json-schema-faker"));
const path_1 = __importDefault(require("path"));
const pify_1 = __importDefault(require("pify"));
const qs_1 = __importDefault(require("qs"));
const seedrandom_1 = __importDefault(require("seedrandom"));
const tempy_1 = __importDefault(require("tempy"));
const HTTP = __importStar(require("."));
// const fixtures = globby.sync('./fixtures/http-response-p.ts')
const fixtures = globby_1.default.sync('./fixtures/**/*.{js,ts}');
json_schema_faker_1.default.option({
    alwaysFakeOptionals: true,
    // make values generated by json-schema-faker deterministic
    random: seedrandom_1.default('NzYxNDdlNjgxYzliN2FkNjFmYjBlMTI5')
});
for (const fixture of fixtures) {
    const { name, dir } = path_1.default.parse(fixture);
    const testConfigPath = path_1.default.join(process.cwd(), dir, 'config.json');
    ava_1.default.serial(name, async (t) => {
        let testConfig = {
            get: true,
            post: true,
            postArray: true
        };
        if (fs_extra_1.default.pathExistsSync(testConfigPath)) {
            testConfig = Object.assign({}, testConfig, require(testConfigPath));
        }
        const outDir = tempy_1.default.directory();
        const definition = await fts_1.generateDefinition(fixture, {
            compilerOptions: {
                outDir
            },
            emit: true
        });
        t.truthy(definition);
        const isHttpResponse = !!definition.returns.http;
        const validator = fts_validator_1.createValidator();
        const paramsDecoder = validator.decoder(definition.params.schema);
        const returnsEncoder = validator.encoder(definition.returns.schema);
        const jsFilePath = path_1.default.join(outDir, `${name}.js`);
        const handler = HTTP.createHttpHandler(definition, jsFilePath);
        t.is(typeof handler, 'function');
        const port = await get_port_1.default();
        const server = await HTTP.createHttpServer(handler, port);
        const url = `http://localhost:${port}`;
        const params = await json_schema_faker_1.default.resolve(definition.params.schema);
        const paramsLocal = clone_deep_1.default(params);
        paramsDecoder(paramsLocal);
        t.is(paramsDecoder.errors, null);
        const paramsArray = definition.params.order.map((key) => params[key]);
        const paramsLocalArray = definition.params.order.map((key) => paramsLocal[key]);
        const func = HTTP.requireHandlerFunction(definition, jsFilePath);
        const result = await Promise.resolve(func(...paramsLocalArray));
        const expected = { result };
        if (!isHttpResponse) {
            returnsEncoder(expected);
            t.is(returnsEncoder.errors, null);
        }
        else {
            expected.result = (result.body || Buffer.from('')).toString();
        }
        const expectedEncoded = JSON.parse(JSON.stringify(expected));
        console.log({ name, params, port, expected });
        // test GET request with params as a query string
        // note: some fixtures will not support this type of encoding
        if (testConfig.get) {
            const query = qs_1.default.stringify(params);
            const temp = { query };
            if (!isHttpResponse) {
                temp.json = true;
            }
            const responseGET = await got_1.default(url, temp);
            validateResponseSuccess(responseGET, 'GET', expectedEncoded);
        }
        // test POST request with params as a json body object
        if (testConfig.post) {
            const temp = { body: params };
            if (isHttpResponse) {
                temp.body = JSON.stringify(params);
                temp.headers = {
                    'Content-type': 'application/json'
                };
            }
            else {
                temp.json = true;
            }
            const responsePOST = await got_1.default.post(url, temp);
            validateResponseSuccess(responsePOST, 'POST', expectedEncoded);
        }
        // test POST request with params as a json body array
        if (testConfig.postArray) {
            const temp = { body: paramsArray };
            if (isHttpResponse) {
                temp.body = JSON.stringify(paramsArray);
                temp.headers = {
                    'Content-type': 'application/json'
                };
            }
            else {
                temp.json = true;
            }
            const responsePOSTArray = await got_1.default.post(url, temp);
            validateResponseSuccess(responsePOSTArray, 'POSTArray', expectedEncoded);
        }
        await pify_1.default(server.close.bind(server))();
        await fs_extra_1.default.remove(outDir);
        function validateResponseSuccess(res, label, expected) {
            console.log({
                body: res.body,
                label,
                statusCode: res.statusCode
            });
            t.is(res.statusCode, 200);
            const response = { result: res.body };
            if (result === undefined || result === null) {
                if (response.result === '') {
                    response.result = result;
                }
            }
            const responseEncoded = JSON.parse(JSON.stringify(response));
            t.deepEqual(responseEncoded, expected);
        }
    });
}
//# sourceMappingURL=handler.test.js.map